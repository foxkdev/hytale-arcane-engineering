package com.tumi.hytale.arcana.tile.logic;

import com.tumi.hytale.arcana.power.IArcaneFlow;
import com.tumi.hytale.arcana.tile.ArcaneFlowBaseTileEntity;
import java.util.HashMap;
import java.util.Map;

/**
 * Runic Linker - Configurable logic gate block.
 * Can be set to AND, OR, or NOT mode.
 * Processes multiple inputs and produces output based on selected logic mode.
 */
public class RunicLinkerTileEntity extends ArcaneFlowBaseTileEntity {

    protected static final int LOGIC_THRESHOLD = 1; // Minimum flow to consider as "true"
    private static final int NOT_OUTPUT_FLOW = 10; // Flow generated by NOT gate when active
    
    protected Map<Direction, Integer> inputFlows = new HashMap<>();
    private LogicMode mode = LogicMode.AND; // Default mode
    
    public enum Direction {
        NORTH, SOUTH, EAST, WEST, UP, DOWN
    }
    
    public enum LogicMode {
        AND,    // Output if ALL inputs are active
        OR,     // Output if ANY input is active
        NOT     // Output if input is NOT active (inverts)
    }
    
    public RunicLinkerTileEntity() {
        super(IArcaneFlow.MAX_FLOW_CAPACITY_BASE);
    }
    
    @Override
    public void tick() {
        // 1. Read inputs from all input directions
        readInputs();
        
        // 2. Calculate logic output based on current mode
        boolean logicResult = calculateLogic();
        
        // 3. Generate output flow based on result
        int targetFlow = logicResult ? getOutputFlow() : 0;
        
        // Adjust current flow towards target
        this.currentFlow = targetFlow;
        
        // 4. Propagate output
        if (currentFlow > 0) {
            propagateOutput();
        }
    }
    
    /**
     * Reads flow values from input directions.
     * For AND/OR: reads NORTH and EAST
     * For NOT: reads only NORTH
     */
    protected void readInputs() {
        inputFlows.clear();
        
        // TODO: Read actual flow from neighboring blocks
        // This is a placeholder - requires Hytale API
        // IArcaneFlow northNeighbor = getNeighbor(Direction.NORTH);
        // IArcaneFlow eastNeighbor = getNeighbor(Direction.EAST);
        // inputFlows.put(Direction.NORTH, northNeighbor != null ? northNeighbor.getCurrentFlow() : 0);
        // inputFlows.put(Direction.EAST, eastNeighbor != null ? eastNeighbor.getCurrentFlow() : 0);
        
        inputFlows.put(Direction.NORTH, 0);
        if (mode != LogicMode.NOT) {
            inputFlows.put(Direction.EAST, 0);
        }
    }
    
    /**
     * Calculates the logic gate output based on current mode and inputs.
     * @return true if gate should output, false otherwise
     */
    protected boolean calculateLogic() {
        int northFlow = inputFlows.getOrDefault(Direction.NORTH, 0);
        int eastFlow = inputFlows.getOrDefault(Direction.EAST, 0);
        
        switch (mode) {
            case AND:
                // AND logic: ALL inputs must be active
                return isFlowActive(northFlow) && isFlowActive(eastFlow);
                
            case OR:
                // OR logic: ANY input must be active
                return isFlowActive(northFlow) || isFlowActive(eastFlow);
                
            case NOT:
                // NOT logic: Invert the input
                return !isFlowActive(northFlow);
                
            default:
                return false;
        }
    }
    
    /**
     * Propagates output to SOUTH direction.
     */
    protected void propagateOutput() {
        if (currentFlow == 0) return;
        
        // TODO: Propagate to SOUTH neighbor
        // IArcaneFlow southNeighbor = getNeighbor(Direction.SOUTH);
        // if (southNeighbor != null) {
        //     int amountToTransfer = currentFlow;
        //     int remainder = southNeighbor.injectFlow(amountToTransfer, true);
        //     int accepted = amountToTransfer - remainder;
        //     if (accepted > 0) {
        //         this.extractFlow(accepted, false);
        //         southNeighbor.injectFlow(accepted, false);
        //     }
        // }
    }
    
    /**
     * Gets the output flow value based on mode.
     * For NOT: generates fixed flow
     * For AND/OR: uses max input flow
     */
    protected int getOutputFlow() {
        if (mode == LogicMode.NOT) {
            return NOT_OUTPUT_FLOW;
        }
        return getMaxInputFlow();
    }
    
    /**
     * Gets the maximum flow value from all inputs.
     * Used to determine output strength.
     */
    protected int getMaxInputFlow() {
        return inputFlows.values().stream()
            .max(Integer::compareTo)
            .orElse(0);
    }
    
    /**
     * Checks if a flow value is considered "true" for logic purposes.
     */
    protected boolean isFlowActive(int flow) {
        return flow >= LOGIC_THRESHOLD;
    }
    
    // --- Configuration Methods ---
    
    /**
     * Cycles through logic modes: AND -> OR -> NOT -> AND
     * Called when player right-clicks the block.
     */
    public void cycleMode() {
        switch (mode) {
            case AND:
                mode = LogicMode.OR;
                break;
            case OR:
                mode = LogicMode.NOT;
                break;
            case NOT:
                mode = LogicMode.AND;
                break;
        }
        // this.markDirty();
    }
    
    /**
     * Sets the logic mode directly.
     * @param newMode The logic mode to set
     */
    public void setMode(LogicMode newMode) {
        this.mode = newMode;
        // this.markDirty();
    }
    
    /**
     * Gets the current logic mode.
     * @return Current logic mode
     */
    public LogicMode getMode() {
        return this.mode;
    }
}
